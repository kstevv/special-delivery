"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/focus-trap-react";
exports.ids = ["vendor-chunks/focus-trap-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js":
/*!****************************************************************!*\
  !*** ./node_modules/focus-trap-react/dist/focus-trap-react.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar ReactDOM = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\nvar PropTypes = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\nvar _require = __webpack_require__(/*! focus-trap */ \"(ssr)/./node_modules/focus-trap/dist/focus-trap.js\"),\n    createFocusTrap = _require.createFocusTrap;\n\nvar _require2 = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.js\"),\n    isFocusable = _require2.isFocusable; // TODO: These issues are related to older React features which we'll likely need\n//  to fix in order to move the code forward to the next major version of React.\n//  @see https://github.com/davidtheclark/focus-trap-react/issues/77\n\n/* eslint-disable react/no-find-dom-node */\n\n\nvar FocusTrap = /*#__PURE__*/function (_React$Component) {\n  _inherits(FocusTrap, _React$Component);\n\n  var _super = _createSuper(FocusTrap);\n\n  function FocusTrap(props) {\n    var _this;\n\n    _classCallCheck(this, FocusTrap);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"getNodeForOption\", function (optionName) {\n      var _this$internalOptions;\n\n      // use internal options first, falling back to original options\n      var optionValue = (_this$internalOptions = this.internalOptions[optionName]) !== null && _this$internalOptions !== void 0 ? _this$internalOptions : this.originalOptions[optionName];\n\n      if (typeof optionValue === 'function') {\n        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          params[_key - 1] = arguments[_key];\n        }\n\n        optionValue = optionValue.apply(void 0, params);\n      }\n\n      if (optionValue === true) {\n        optionValue = undefined; // use default value\n      }\n\n      if (!optionValue) {\n        if (optionValue === undefined || optionValue === false) {\n          return optionValue;\n        } // else, empty string (invalid), null (invalid), 0 (invalid)\n\n\n        throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n      }\n\n      var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n      if (typeof optionValue === 'string') {\n        var _this$getDocument;\n\n        node = (_this$getDocument = this.getDocument()) === null || _this$getDocument === void 0 ? void 0 : _this$getDocument.querySelector(optionValue); // resolve to node, or null if fails\n\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n        }\n      }\n\n      return node;\n    });\n\n    _this.handleDeactivate = _this.handleDeactivate.bind(_assertThisInitialized(_this));\n    _this.handlePostDeactivate = _this.handlePostDeactivate.bind(_assertThisInitialized(_this));\n    _this.handleClickOutsideDeactivates = _this.handleClickOutsideDeactivates.bind(_assertThisInitialized(_this)); // focus-trap options used internally when creating the trap\n\n    _this.internalOptions = {\n      // We need to hijack the returnFocusOnDeactivate option,\n      // because React can move focus into the element before we arrived at\n      // this lifecycle hook (e.g. with autoFocus inputs). So the component\n      // captures the previouslyFocusedElement in componentWillMount,\n      // then (optionally) returns focus to it in componentWillUnmount.\n      returnFocusOnDeactivate: false,\n      // the rest of these are also related to deactivation of the trap, and we\n      //  need to use them and control them as well\n      checkCanReturnFocus: null,\n      onDeactivate: _this.handleDeactivate,\n      onPostDeactivate: _this.handlePostDeactivate,\n      // we need to special-case this setting as well so that we can know if we should\n      //  NOT return focus if the trap gets auto-deactivated as the result of an\n      //  outside click (otherwise, we'll always think we should return focus because\n      //  of how we manage that flag internally here)\n      clickOutsideDeactivates: _this.handleClickOutsideDeactivates\n    }; // original options provided by the consumer\n\n    _this.originalOptions = {\n      // because of the above `internalOptions`, we maintain our own flag for\n      //  this option, and default it to `true` because that's focus-trap's default\n      returnFocusOnDeactivate: true,\n      // because of the above `internalOptions`, we keep these separate since\n      //  they're part of the deactivation process which we configure (internally) to\n      //  be shared between focus-trap and focus-trap-react\n      onDeactivate: null,\n      onPostDeactivate: null,\n      checkCanReturnFocus: null,\n      // the user's setting, defaulted to false since focus-trap defaults this to false\n      clickOutsideDeactivates: false\n    };\n    var focusTrapOptions = props.focusTrapOptions;\n\n    for (var optionName in focusTrapOptions) {\n      if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n        continue;\n      }\n\n      if (optionName === 'returnFocusOnDeactivate' || optionName === 'onDeactivate' || optionName === 'onPostDeactivate' || optionName === 'checkCanReturnFocus' || optionName === 'clickOutsideDeactivates') {\n        _this.originalOptions[optionName] = focusTrapOptions[optionName];\n        continue; // exclude from internalOptions\n      }\n\n      _this.internalOptions[optionName] = focusTrapOptions[optionName];\n    } // if set, `{ target: Node, allowDeactivation: boolean }` where `target` is the outside\n    //  node that was clicked, and `allowDeactivation` is the result of the consumer's\n    //  option (stored in `this.originalOptions.clickOutsideDeactivates`, which may be a\n    //  function) whether to allow or deny auto-deactivation on click on this outside node\n\n\n    _this.outsideClick = null; // elements from which to create the focus trap on mount; if a child is used\n    //  instead of the `containerElements` prop, we'll get the child's related\n    //  element when the trap renders and then is declared 'mounted'\n\n    _this.focusTrapElements = props.containerElements || []; // now we remember what the currently focused element is, not relying on focus-trap\n\n    _this.updatePreviousElement();\n\n    return _this;\n  }\n  /**\n   * Gets the configured document.\n   * @returns {Document|undefined} Configured document, falling back to the main\n   *  document, if it exists. During SSR, `undefined` is returned since the\n   *  document doesn't exist.\n   */\n\n\n  _createClass(FocusTrap, [{\n    key: \"getDocument\",\n    value: function getDocument() {\n      // SSR: careful to check if `document` exists before accessing it as a variable\n      return this.props.focusTrapOptions.document || (typeof document !== 'undefined' ? document : undefined);\n    }\n    /**\n     * Gets the node for the given option, which is expected to be an option that\n     *  can be either a DOM node, a string that is a selector to get a node, `false`\n     *  (if a node is explicitly NOT given), or a function that returns any of these\n     *  values.\n     * @param {string} optionName\n     * @returns {undefined | false | HTMLElement | SVGElement} Returns\n     *  `undefined` if the option is not specified; `false` if the option\n     *  resolved to `false` (node explicitly not given); otherwise, the resolved\n     *  DOM node.\n     * @throws {Error} If the option is set, not `false`, and is not, or does not\n     *  resolve to a node.\n     */\n\n  }, {\n    key: \"getReturnFocusNode\",\n    value: function getReturnFocusNode() {\n      var node = this.getNodeForOption('setReturnFocus', this.previouslyFocusedElement);\n      return node ? node : node === false ? false : this.previouslyFocusedElement;\n    }\n    /** Update the previously focused element with the currently focused element. */\n\n  }, {\n    key: \"updatePreviousElement\",\n    value: function updatePreviousElement() {\n      var currentDocument = this.getDocument();\n\n      if (currentDocument) {\n        this.previouslyFocusedElement = currentDocument.activeElement;\n      }\n    }\n  }, {\n    key: \"deactivateTrap\",\n    value: function deactivateTrap() {\n      // NOTE: it's possible the focus trap has already been deactivated without our knowing it,\n      //  especially if the user set the `clickOutsideDeactivates: true` option on the trap,\n      //  and the mouse was clicked on some element outside the trap; at that point, focus-trap\n      //  will initiate its auto-deactivation process, which will call our own\n      //  handleDeactivate(), which will call into this method\n      if (!this.focusTrap || !this.focusTrap.active) {\n        return;\n      }\n\n      this.focusTrap.deactivate({\n        // NOTE: we never let the trap return the focus since we do that ourselves\n        returnFocus: false,\n        // we'll call this in our own post deactivate handler so make sure the trap doesn't\n        //  do it prematurely\n        checkCanReturnFocus: null,\n        // let it call the user's original deactivate handler, if any, instead of\n        //  our own which calls back into this function\n        onDeactivate: this.originalOptions.onDeactivate // NOTE: for post deactivate, don't specify anything so that it calls the\n        //  onPostDeactivate handler specified on `this.internalOptions`\n        //  which will always be our own `handlePostDeactivate()` handler, which\n        //  will finish things off by calling the user's provided onPostDeactivate\n        //  handler, if any, at the right time\n        // onPostDeactivate: NOTHING\n\n      });\n    }\n  }, {\n    key: \"handleClickOutsideDeactivates\",\n    value: function handleClickOutsideDeactivates(event) {\n      // use consumer's option (or call their handler) as the permission or denial\n      var allowDeactivation = typeof this.originalOptions.clickOutsideDeactivates === 'function' ? this.originalOptions.clickOutsideDeactivates.call(null, event) // call out of context\n      : this.originalOptions.clickOutsideDeactivates; // boolean\n\n      if (allowDeactivation) {\n        // capture the outside target that was clicked so we can use it in the deactivation\n        //  process since the consumer allowed it to cause auto-deactivation\n        this.outsideClick = {\n          target: event.target,\n          allowDeactivation: allowDeactivation\n        };\n      }\n\n      return allowDeactivation;\n    }\n  }, {\n    key: \"handleDeactivate\",\n    value: function handleDeactivate() {\n      if (this.originalOptions.onDeactivate) {\n        this.originalOptions.onDeactivate.call(null); // call user's handler out of context\n      }\n\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"handlePostDeactivate\",\n    value: function handlePostDeactivate() {\n      var _this2 = this;\n\n      var finishDeactivation = function finishDeactivation() {\n        var returnFocusNode = _this2.getReturnFocusNode();\n\n        var canReturnFocus = !!( // did the consumer allow it?\n        _this2.originalOptions.returnFocusOnDeactivate && // can we actually focus the node?\n        returnFocusNode !== null && returnFocusNode !== void 0 && returnFocusNode.focus && ( // was there an outside click that allowed deactivation?\n        !_this2.outsideClick || // did the consumer allow deactivation when the outside node was clicked?\n        _this2.outsideClick.allowDeactivation && // is the outside node NOT focusable (implying that it did NOT receive focus\n        //  as a result of the click-through) -- in which case do NOT restore focus\n        //  to `returnFocusNode` because focus should remain on the outside node\n        !isFocusable(_this2.outsideClick.target, _this2.internalOptions.tabbableOptions)) // if no, the restore focus to `returnFocusNode` at this point\n        );\n        var _this2$internalOption = _this2.internalOptions.preventScroll,\n            preventScroll = _this2$internalOption === void 0 ? false : _this2$internalOption;\n\n        if (canReturnFocus) {\n          // return focus to the element that had focus when the trap was activated\n          returnFocusNode.focus({\n            preventScroll: preventScroll\n          });\n        }\n\n        if (_this2.originalOptions.onPostDeactivate) {\n          _this2.originalOptions.onPostDeactivate.call(null); // don't call it in context of \"this\"\n\n        }\n\n        _this2.outsideClick = null; // reset: no longer needed\n      };\n\n      if (this.originalOptions.checkCanReturnFocus) {\n        this.originalOptions.checkCanReturnFocus.call(null, this.getReturnFocusNode()) // call out of context\n        .then(finishDeactivation, finishDeactivation);\n      } else {\n        finishDeactivation();\n      }\n    }\n  }, {\n    key: \"setupFocusTrap\",\n    value: function setupFocusTrap() {\n      if (!this.focusTrap) {\n        var focusTrapElementDOMNodes = this.focusTrapElements.map( // NOTE: `findDOMNode()` does not support CSS selectors; it'll just return\n        //  a new text node with the text wrapped in it instead of treating the\n        //  string as a selector and resolving it to a node in the DOM\n        ReactDOM.findDOMNode);\n        var nodesExist = focusTrapElementDOMNodes.some(Boolean);\n\n        if (nodesExist) {\n          // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n          this.focusTrap = this.props._createFocusTrap(focusTrapElementDOMNodes, this.internalOptions);\n\n          if (this.props.active) {\n            this.focusTrap.activate();\n          }\n\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.active) {\n        this.setupFocusTrap();\n      } // else, wait for later activation in case the `focusTrapOptions` will be updated\n      //  again before the trap is activated (e.g. if waiting to know what the document\n      //  object will be, so the Trap must be rendered, but the consumer is waiting to\n      //  activate until they have obtained the document from a ref)\n      //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.focusTrap) {\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrap.updateContainerElements(this.props.containerElements);\n        }\n\n        var hasActivated = !prevProps.active && this.props.active;\n        var hasDeactivated = prevProps.active && !this.props.active;\n        var hasPaused = !prevProps.paused && this.props.paused;\n        var hasUnpaused = prevProps.paused && !this.props.paused;\n\n        if (hasActivated) {\n          this.updatePreviousElement();\n          this.focusTrap.activate();\n        }\n\n        if (hasDeactivated) {\n          this.deactivateTrap();\n          return; // un/pause does nothing on an inactive trap\n        }\n\n        if (hasPaused) {\n          this.focusTrap.pause();\n        }\n\n        if (hasUnpaused) {\n          this.focusTrap.unpause();\n        }\n      } else {\n        // NOTE: if we're in `componentDidUpdate` and we don't have a trap yet,\n        //  it either means it shouldn't be active, or it should be but none of\n        //  of given `containerElements` were present in the DOM the last time\n        //  we tried to create the trap\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrapElements = this.props.containerElements;\n        } // don't create the trap unless it should be active in case the consumer\n        //  is still updating `focusTrapOptions`\n        //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n\n\n        if (this.props.active) {\n          this.updatePreviousElement();\n          this.setupFocusTrap();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n\n      if (child) {\n        if (child.type && child.type === React.Fragment) {\n          throw new Error('A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.');\n        }\n\n        var composedRefCallback = function composedRefCallback(element) {\n          var containerElements = _this3.props.containerElements;\n\n          if (child) {\n            if (typeof child.ref === 'function') {\n              child.ref(element);\n            } else if (child.ref) {\n              child.ref.current = element;\n            }\n          }\n\n          _this3.focusTrapElements = containerElements ? containerElements : [element];\n        };\n\n        var childWithRef = React.cloneElement(child, {\n          ref: composedRefCallback\n        });\n        return childWithRef;\n      }\n\n      return null;\n    }\n  }]);\n\n  return FocusTrap;\n}(React.Component); // support server-side rendering where `Element` will not be defined\n\n\nvar ElementType = typeof Element === 'undefined' ? Function : Element;\nFocusTrap.propTypes = {\n  active: PropTypes.bool,\n  paused: PropTypes.bool,\n  focusTrapOptions: PropTypes.shape({\n    document: PropTypes.object,\n    onActivate: PropTypes.func,\n    onPostActivate: PropTypes.func,\n    checkCanFocusTrap: PropTypes.func,\n    onDeactivate: PropTypes.func,\n    onPostDeactivate: PropTypes.func,\n    checkCanReturnFocus: PropTypes.func,\n    initialFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.bool, PropTypes.func]),\n    fallbackFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, // NOTE: does not support `false` as value (or return value from function)\n    PropTypes.func]),\n    escapeDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    clickOutsideDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    returnFocusOnDeactivate: PropTypes.bool,\n    setReturnFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.bool, PropTypes.func]),\n    allowOutsideClick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    preventScroll: PropTypes.bool,\n    tabbableOptions: PropTypes.shape({\n      displayCheck: PropTypes.oneOf(['full', 'non-zero-area', 'none']),\n      getShadowRoot: PropTypes.oneOfType([PropTypes.bool, PropTypes.func])\n    })\n  }),\n  containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n  children: PropTypes.oneOfType([PropTypes.element, // React element\n  PropTypes.instanceOf(ElementType) // DOM element\n  ]) // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't\n  //  specify it here. It's expected to be set to the function returned from\n  //  require('focus-trap'), or one with a compatible interface.\n\n};\nFocusTrap.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC1yZWFjdC9kaXN0L2ZvY3VzLXRyYXAtcmVhY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLDJCQUEyQixzR0FBc0cscUJBQXFCLG1CQUFtQiw4SEFBOEg7O0FBRS9ULGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7O0FBRXhRLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHLCtDQUErQyxpQkFBaUIsR0FBRzs7QUFFNVksaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTs7QUFFekssaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWUsNEJBQTRCLG1GQUFtRjs7QUFFMVAsd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsOEJBQThCLHVHQUF1RyxtREFBbUQ7O0FBRXhMLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9COztBQUVwTSxZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCLGVBQWUsbUJBQU8sQ0FBQyxnSEFBVzs7QUFFbEMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVk7O0FBRXBDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBWTtBQUNuQzs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVTtBQUNsQyx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlHQUFpRyxhQUFhO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQSwwSkFBMEo7O0FBRTFKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUhBQW1IOztBQUVuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQSxNQUFNLGNBQWMsMENBQTBDO0FBQzlEO0FBQ0E7QUFDQTs7O0FBR0EsK0JBQStCLDBEQUEwRDtBQUN6RjtBQUNBOztBQUVBLDZEQUE2RDs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLDhDQUE4QztBQUMvRCxvREFBb0Q7QUFDcEQseURBQXlEO0FBQ3pEO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSw4REFBOEQ7O0FBRTlEOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsbUJBQW1COzs7QUFHcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BlY2lhbC1kZWxpdmVyeS8uL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwLXJlYWN0L2Rpc3QvZm9jdXMtdHJhcC1yZWFjdC5qcz83YmFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2ZvY3VzLXRyYXAnKSxcbiAgICBjcmVhdGVGb2N1c1RyYXAgPSBfcmVxdWlyZS5jcmVhdGVGb2N1c1RyYXA7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd0YWJiYWJsZScpLFxuICAgIGlzRm9jdXNhYmxlID0gX3JlcXVpcmUyLmlzRm9jdXNhYmxlOyAvLyBUT0RPOiBUaGVzZSBpc3N1ZXMgYXJlIHJlbGF0ZWQgdG8gb2xkZXIgUmVhY3QgZmVhdHVyZXMgd2hpY2ggd2UnbGwgbGlrZWx5IG5lZWRcbi8vICB0byBmaXggaW4gb3JkZXIgdG8gbW92ZSB0aGUgY29kZSBmb3J3YXJkIHRvIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgUmVhY3QuXG4vLyAgQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGF2aWR0aGVjbGFyay9mb2N1cy10cmFwLXJlYWN0L2lzc3Vlcy83N1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9uby1maW5kLWRvbS1ub2RlICovXG5cblxudmFyIEZvY3VzVHJhcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRm9jdXNUcmFwLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEZvY3VzVHJhcCk7XG5cbiAgZnVuY3Rpb24gRm9jdXNUcmFwKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvY3VzVHJhcCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXROb2RlRm9yT3B0aW9uXCIsIGZ1bmN0aW9uIChvcHRpb25OYW1lKSB7XG4gICAgICB2YXIgX3RoaXMkaW50ZXJuYWxPcHRpb25zO1xuXG4gICAgICAvLyB1c2UgaW50ZXJuYWwgb3B0aW9ucyBmaXJzdCwgZmFsbGluZyBiYWNrIHRvIG9yaWdpbmFsIG9wdGlvbnNcbiAgICAgIHZhciBvcHRpb25WYWx1ZSA9IChfdGhpcyRpbnRlcm5hbE9wdGlvbnMgPSB0aGlzLmludGVybmFsT3B0aW9uc1tvcHRpb25OYW1lXSkgIT09IG51bGwgJiYgX3RoaXMkaW50ZXJuYWxPcHRpb25zICE9PSB2b2lkIDAgPyBfdGhpcyRpbnRlcm5hbE9wdGlvbnMgOiB0aGlzLm9yaWdpbmFsT3B0aW9uc1tvcHRpb25OYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBwYXJhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9uVmFsdWUgPSBvcHRpb25WYWx1ZS5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcHRpb25WYWx1ZSA9IHVuZGVmaW5lZDsgLy8gdXNlIGRlZmF1bHQgdmFsdWVcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgICBpZiAob3B0aW9uVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9uVmFsdWU7XG4gICAgICAgIH0gLy8gZWxzZSwgZW1wdHkgc3RyaW5nIChpbnZhbGlkKSwgbnVsbCAoaW52YWxpZCksIDAgKGludmFsaWQpXG5cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCB3YXMgc3BlY2lmaWVkIGJ1dCB3YXMgbm90IGEgbm9kZSwgb3IgZGlkIG5vdCByZXR1cm4gYSBub2RlXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBvcHRpb25WYWx1ZTsgLy8gY291bGQgYmUgSFRNTEVsZW1lbnQsIFNWR0VsZW1lbnQsIG9yIG5vbi1lbXB0eSBzdHJpbmcgYXQgdGhpcyBwb2ludFxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgX3RoaXMkZ2V0RG9jdW1lbnQ7XG5cbiAgICAgICAgbm9kZSA9IChfdGhpcyRnZXREb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0RG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldERvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9uVmFsdWUpOyAvLyByZXNvbHZlIHRvIG5vZGUsIG9yIG51bGwgaWYgZmFpbHNcblxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCBhcyBzZWxlY3RvciByZWZlcnMgdG8gbm8ga25vd24gbm9kZVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5oYW5kbGVEZWFjdGl2YXRlID0gX3RoaXMuaGFuZGxlRGVhY3RpdmF0ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVQb3N0RGVhY3RpdmF0ZSA9IF90aGlzLmhhbmRsZVBvc3REZWFjdGl2YXRlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZUNsaWNrT3V0c2lkZURlYWN0aXZhdGVzID0gX3RoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7IC8vIGZvY3VzLXRyYXAgb3B0aW9ucyB1c2VkIGludGVybmFsbHkgd2hlbiBjcmVhdGluZyB0aGUgdHJhcFxuXG4gICAgX3RoaXMuaW50ZXJuYWxPcHRpb25zID0ge1xuICAgICAgLy8gV2UgbmVlZCB0byBoaWphY2sgdGhlIHJldHVybkZvY3VzT25EZWFjdGl2YXRlIG9wdGlvbixcbiAgICAgIC8vIGJlY2F1c2UgUmVhY3QgY2FuIG1vdmUgZm9jdXMgaW50byB0aGUgZWxlbWVudCBiZWZvcmUgd2UgYXJyaXZlZCBhdFxuICAgICAgLy8gdGhpcyBsaWZlY3ljbGUgaG9vayAoZS5nLiB3aXRoIGF1dG9Gb2N1cyBpbnB1dHMpLiBTbyB0aGUgY29tcG9uZW50XG4gICAgICAvLyBjYXB0dXJlcyB0aGUgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50IGluIGNvbXBvbmVudFdpbGxNb3VudCxcbiAgICAgIC8vIHRoZW4gKG9wdGlvbmFsbHkpIHJldHVybnMgZm9jdXMgdG8gaXQgaW4gY29tcG9uZW50V2lsbFVubW91bnQuXG4gICAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogZmFsc2UsXG4gICAgICAvLyB0aGUgcmVzdCBvZiB0aGVzZSBhcmUgYWxzbyByZWxhdGVkIHRvIGRlYWN0aXZhdGlvbiBvZiB0aGUgdHJhcCwgYW5kIHdlXG4gICAgICAvLyAgbmVlZCB0byB1c2UgdGhlbSBhbmQgY29udHJvbCB0aGVtIGFzIHdlbGxcbiAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXM6IG51bGwsXG4gICAgICBvbkRlYWN0aXZhdGU6IF90aGlzLmhhbmRsZURlYWN0aXZhdGUsXG4gICAgICBvblBvc3REZWFjdGl2YXRlOiBfdGhpcy5oYW5kbGVQb3N0RGVhY3RpdmF0ZSxcbiAgICAgIC8vIHdlIG5lZWQgdG8gc3BlY2lhbC1jYXNlIHRoaXMgc2V0dGluZyBhcyB3ZWxsIHNvIHRoYXQgd2UgY2FuIGtub3cgaWYgd2Ugc2hvdWxkXG4gICAgICAvLyAgTk9UIHJldHVybiBmb2N1cyBpZiB0aGUgdHJhcCBnZXRzIGF1dG8tZGVhY3RpdmF0ZWQgYXMgdGhlIHJlc3VsdCBvZiBhblxuICAgICAgLy8gIG91dHNpZGUgY2xpY2sgKG90aGVyd2lzZSwgd2UnbGwgYWx3YXlzIHRoaW5rIHdlIHNob3VsZCByZXR1cm4gZm9jdXMgYmVjYXVzZVxuICAgICAgLy8gIG9mIGhvdyB3ZSBtYW5hZ2UgdGhhdCBmbGFnIGludGVybmFsbHkgaGVyZSlcbiAgICAgIGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiBfdGhpcy5oYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlc1xuICAgIH07IC8vIG9yaWdpbmFsIG9wdGlvbnMgcHJvdmlkZWQgYnkgdGhlIGNvbnN1bWVyXG5cbiAgICBfdGhpcy5vcmlnaW5hbE9wdGlvbnMgPSB7XG4gICAgICAvLyBiZWNhdXNlIG9mIHRoZSBhYm92ZSBgaW50ZXJuYWxPcHRpb25zYCwgd2UgbWFpbnRhaW4gb3VyIG93biBmbGFnIGZvclxuICAgICAgLy8gIHRoaXMgb3B0aW9uLCBhbmQgZGVmYXVsdCBpdCB0byBgdHJ1ZWAgYmVjYXVzZSB0aGF0J3MgZm9jdXMtdHJhcCdzIGRlZmF1bHRcbiAgICAgIHJldHVybkZvY3VzT25EZWFjdGl2YXRlOiB0cnVlLFxuICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgYWJvdmUgYGludGVybmFsT3B0aW9uc2AsIHdlIGtlZXAgdGhlc2Ugc2VwYXJhdGUgc2luY2VcbiAgICAgIC8vICB0aGV5J3JlIHBhcnQgb2YgdGhlIGRlYWN0aXZhdGlvbiBwcm9jZXNzIHdoaWNoIHdlIGNvbmZpZ3VyZSAoaW50ZXJuYWxseSkgdG9cbiAgICAgIC8vICBiZSBzaGFyZWQgYmV0d2VlbiBmb2N1cy10cmFwIGFuZCBmb2N1cy10cmFwLXJlYWN0XG4gICAgICBvbkRlYWN0aXZhdGU6IG51bGwsXG4gICAgICBvblBvc3REZWFjdGl2YXRlOiBudWxsLFxuICAgICAgY2hlY2tDYW5SZXR1cm5Gb2N1czogbnVsbCxcbiAgICAgIC8vIHRoZSB1c2VyJ3Mgc2V0dGluZywgZGVmYXVsdGVkIHRvIGZhbHNlIHNpbmNlIGZvY3VzLXRyYXAgZGVmYXVsdHMgdGhpcyB0byBmYWxzZVxuICAgICAgY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXM6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgZm9jdXNUcmFwT3B0aW9ucyA9IHByb3BzLmZvY3VzVHJhcE9wdGlvbnM7XG5cbiAgICBmb3IgKHZhciBvcHRpb25OYW1lIGluIGZvY3VzVHJhcE9wdGlvbnMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvY3VzVHJhcE9wdGlvbnMsIG9wdGlvbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9uTmFtZSA9PT0gJ3JldHVybkZvY3VzT25EZWFjdGl2YXRlJyB8fCBvcHRpb25OYW1lID09PSAnb25EZWFjdGl2YXRlJyB8fCBvcHRpb25OYW1lID09PSAnb25Qb3N0RGVhY3RpdmF0ZScgfHwgb3B0aW9uTmFtZSA9PT0gJ2NoZWNrQ2FuUmV0dXJuRm9jdXMnIHx8IG9wdGlvbk5hbWUgPT09ICdjbGlja091dHNpZGVEZWFjdGl2YXRlcycpIHtcbiAgICAgICAgX3RoaXMub3JpZ2luYWxPcHRpb25zW29wdGlvbk5hbWVdID0gZm9jdXNUcmFwT3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICAgICAgY29udGludWU7IC8vIGV4Y2x1ZGUgZnJvbSBpbnRlcm5hbE9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgX3RoaXMuaW50ZXJuYWxPcHRpb25zW29wdGlvbk5hbWVdID0gZm9jdXNUcmFwT3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICB9IC8vIGlmIHNldCwgYHsgdGFyZ2V0OiBOb2RlLCBhbGxvd0RlYWN0aXZhdGlvbjogYm9vbGVhbiB9YCB3aGVyZSBgdGFyZ2V0YCBpcyB0aGUgb3V0c2lkZVxuICAgIC8vICBub2RlIHRoYXQgd2FzIGNsaWNrZWQsIGFuZCBgYWxsb3dEZWFjdGl2YXRpb25gIGlzIHRoZSByZXN1bHQgb2YgdGhlIGNvbnN1bWVyJ3NcbiAgICAvLyAgb3B0aW9uIChzdG9yZWQgaW4gYHRoaXMub3JpZ2luYWxPcHRpb25zLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzYCwgd2hpY2ggbWF5IGJlIGFcbiAgICAvLyAgZnVuY3Rpb24pIHdoZXRoZXIgdG8gYWxsb3cgb3IgZGVueSBhdXRvLWRlYWN0aXZhdGlvbiBvbiBjbGljayBvbiB0aGlzIG91dHNpZGUgbm9kZVxuXG5cbiAgICBfdGhpcy5vdXRzaWRlQ2xpY2sgPSBudWxsOyAvLyBlbGVtZW50cyBmcm9tIHdoaWNoIHRvIGNyZWF0ZSB0aGUgZm9jdXMgdHJhcCBvbiBtb3VudDsgaWYgYSBjaGlsZCBpcyB1c2VkXG4gICAgLy8gIGluc3RlYWQgb2YgdGhlIGBjb250YWluZXJFbGVtZW50c2AgcHJvcCwgd2UnbGwgZ2V0IHRoZSBjaGlsZCdzIHJlbGF0ZWRcbiAgICAvLyAgZWxlbWVudCB3aGVuIHRoZSB0cmFwIHJlbmRlcnMgYW5kIHRoZW4gaXMgZGVjbGFyZWQgJ21vdW50ZWQnXG5cbiAgICBfdGhpcy5mb2N1c1RyYXBFbGVtZW50cyA9IHByb3BzLmNvbnRhaW5lckVsZW1lbnRzIHx8IFtdOyAvLyBub3cgd2UgcmVtZW1iZXIgd2hhdCB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCBpcywgbm90IHJlbHlpbmcgb24gZm9jdXMtdHJhcFxuXG4gICAgX3RoaXMudXBkYXRlUHJldmlvdXNFbGVtZW50KCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbmZpZ3VyZWQgZG9jdW1lbnQuXG4gICAqIEByZXR1cm5zIHtEb2N1bWVudHx1bmRlZmluZWR9IENvbmZpZ3VyZWQgZG9jdW1lbnQsIGZhbGxpbmcgYmFjayB0byB0aGUgbWFpblxuICAgKiAgZG9jdW1lbnQsIGlmIGl0IGV4aXN0cy4gRHVyaW5nIFNTUiwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgc2luY2UgdGhlXG4gICAqICBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhGb2N1c1RyYXAsIFt7XG4gICAga2V5OiBcImdldERvY3VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgICAgLy8gU1NSOiBjYXJlZnVsIHRvIGNoZWNrIGlmIGBkb2N1bWVudGAgZXhpc3RzIGJlZm9yZSBhY2Nlc3NpbmcgaXQgYXMgYSB2YXJpYWJsZVxuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZm9jdXNUcmFwT3B0aW9ucy5kb2N1bWVudCB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbm9kZSBmb3IgdGhlIGdpdmVuIG9wdGlvbiwgd2hpY2ggaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb3B0aW9uIHRoYXRcbiAgICAgKiAgY2FuIGJlIGVpdGhlciBhIERPTSBub2RlLCBhIHN0cmluZyB0aGF0IGlzIGEgc2VsZWN0b3IgdG8gZ2V0IGEgbm9kZSwgYGZhbHNlYFxuICAgICAqICAoaWYgYSBub2RlIGlzIGV4cGxpY2l0bHkgTk9UIGdpdmVuKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW55IG9mIHRoZXNlXG4gICAgICogIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWQgfCBmYWxzZSB8IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gUmV0dXJuc1xuICAgICAqICBgdW5kZWZpbmVkYCBpZiB0aGUgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQ7IGBmYWxzZWAgaWYgdGhlIG9wdGlvblxuICAgICAqICByZXNvbHZlZCB0byBgZmFsc2VgIChub2RlIGV4cGxpY2l0bHkgbm90IGdpdmVuKTsgb3RoZXJ3aXNlLCB0aGUgcmVzb2x2ZWRcbiAgICAgKiAgRE9NIG5vZGUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBvcHRpb24gaXMgc2V0LCBub3QgYGZhbHNlYCwgYW5kIGlzIG5vdCwgb3IgZG9lcyBub3RcbiAgICAgKiAgcmVzb2x2ZSB0byBhIG5vZGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZXR1cm5Gb2N1c05vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmV0dXJuRm9jdXNOb2RlKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGVGb3JPcHRpb24oJ3NldFJldHVybkZvY3VzJywgdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuICAgICAgcmV0dXJuIG5vZGUgPyBub2RlIDogbm9kZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRoaXMucHJldmlvdXNseUZvY3VzZWRFbGVtZW50O1xuICAgIH1cbiAgICAvKiogVXBkYXRlIHRoZSBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCB3aXRoIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50LiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUHJldmlvdXNFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVByZXZpb3VzRWxlbWVudCgpIHtcbiAgICAgIHZhciBjdXJyZW50RG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KCk7XG5cbiAgICAgIGlmIChjdXJyZW50RG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBjdXJyZW50RG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVhY3RpdmF0ZVRyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVhY3RpdmF0ZVRyYXAoKSB7XG4gICAgICAvLyBOT1RFOiBpdCdzIHBvc3NpYmxlIHRoZSBmb2N1cyB0cmFwIGhhcyBhbHJlYWR5IGJlZW4gZGVhY3RpdmF0ZWQgd2l0aG91dCBvdXIga25vd2luZyBpdCxcbiAgICAgIC8vICBlc3BlY2lhbGx5IGlmIHRoZSB1c2VyIHNldCB0aGUgYGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiB0cnVlYCBvcHRpb24gb24gdGhlIHRyYXAsXG4gICAgICAvLyAgYW5kIHRoZSBtb3VzZSB3YXMgY2xpY2tlZCBvbiBzb21lIGVsZW1lbnQgb3V0c2lkZSB0aGUgdHJhcDsgYXQgdGhhdCBwb2ludCwgZm9jdXMtdHJhcFxuICAgICAgLy8gIHdpbGwgaW5pdGlhdGUgaXRzIGF1dG8tZGVhY3RpdmF0aW9uIHByb2Nlc3MsIHdoaWNoIHdpbGwgY2FsbCBvdXIgb3duXG4gICAgICAvLyAgaGFuZGxlRGVhY3RpdmF0ZSgpLCB3aGljaCB3aWxsIGNhbGwgaW50byB0aGlzIG1ldGhvZFxuICAgICAgaWYgKCF0aGlzLmZvY3VzVHJhcCB8fCAhdGhpcy5mb2N1c1RyYXAuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mb2N1c1RyYXAuZGVhY3RpdmF0ZSh7XG4gICAgICAgIC8vIE5PVEU6IHdlIG5ldmVyIGxldCB0aGUgdHJhcCByZXR1cm4gdGhlIGZvY3VzIHNpbmNlIHdlIGRvIHRoYXQgb3Vyc2VsdmVzXG4gICAgICAgIHJldHVybkZvY3VzOiBmYWxzZSxcbiAgICAgICAgLy8gd2UnbGwgY2FsbCB0aGlzIGluIG91ciBvd24gcG9zdCBkZWFjdGl2YXRlIGhhbmRsZXIgc28gbWFrZSBzdXJlIHRoZSB0cmFwIGRvZXNuJ3RcbiAgICAgICAgLy8gIGRvIGl0IHByZW1hdHVyZWx5XG4gICAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXM6IG51bGwsXG4gICAgICAgIC8vIGxldCBpdCBjYWxsIHRoZSB1c2VyJ3Mgb3JpZ2luYWwgZGVhY3RpdmF0ZSBoYW5kbGVyLCBpZiBhbnksIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gIG91ciBvd24gd2hpY2ggY2FsbHMgYmFjayBpbnRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgb25EZWFjdGl2YXRlOiB0aGlzLm9yaWdpbmFsT3B0aW9ucy5vbkRlYWN0aXZhdGUgLy8gTk9URTogZm9yIHBvc3QgZGVhY3RpdmF0ZSwgZG9uJ3Qgc3BlY2lmeSBhbnl0aGluZyBzbyB0aGF0IGl0IGNhbGxzIHRoZVxuICAgICAgICAvLyAgb25Qb3N0RGVhY3RpdmF0ZSBoYW5kbGVyIHNwZWNpZmllZCBvbiBgdGhpcy5pbnRlcm5hbE9wdGlvbnNgXG4gICAgICAgIC8vICB3aGljaCB3aWxsIGFsd2F5cyBiZSBvdXIgb3duIGBoYW5kbGVQb3N0RGVhY3RpdmF0ZSgpYCBoYW5kbGVyLCB3aGljaFxuICAgICAgICAvLyAgd2lsbCBmaW5pc2ggdGhpbmdzIG9mZiBieSBjYWxsaW5nIHRoZSB1c2VyJ3MgcHJvdmlkZWQgb25Qb3N0RGVhY3RpdmF0ZVxuICAgICAgICAvLyAgaGFuZGxlciwgaWYgYW55LCBhdCB0aGUgcmlnaHQgdGltZVxuICAgICAgICAvLyBvblBvc3REZWFjdGl2YXRlOiBOT1RISU5HXG5cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlcyhldmVudCkge1xuICAgICAgLy8gdXNlIGNvbnN1bWVyJ3Mgb3B0aW9uIChvciBjYWxsIHRoZWlyIGhhbmRsZXIpIGFzIHRoZSBwZXJtaXNzaW9uIG9yIGRlbmlhbFxuICAgICAgdmFyIGFsbG93RGVhY3RpdmF0aW9uID0gdHlwZW9mIHRoaXMub3JpZ2luYWxPcHRpb25zLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcmlnaW5hbE9wdGlvbnMuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMuY2FsbChudWxsLCBldmVudCkgLy8gY2FsbCBvdXQgb2YgY29udGV4dFxuICAgICAgOiB0aGlzLm9yaWdpbmFsT3B0aW9ucy5jbGlja091dHNpZGVEZWFjdGl2YXRlczsgLy8gYm9vbGVhblxuXG4gICAgICBpZiAoYWxsb3dEZWFjdGl2YXRpb24pIHtcbiAgICAgICAgLy8gY2FwdHVyZSB0aGUgb3V0c2lkZSB0YXJnZXQgdGhhdCB3YXMgY2xpY2tlZCBzbyB3ZSBjYW4gdXNlIGl0IGluIHRoZSBkZWFjdGl2YXRpb25cbiAgICAgICAgLy8gIHByb2Nlc3Mgc2luY2UgdGhlIGNvbnN1bWVyIGFsbG93ZWQgaXQgdG8gY2F1c2UgYXV0by1kZWFjdGl2YXRpb25cbiAgICAgICAgdGhpcy5vdXRzaWRlQ2xpY2sgPSB7XG4gICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgYWxsb3dEZWFjdGl2YXRpb246IGFsbG93RGVhY3RpdmF0aW9uXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGxvd0RlYWN0aXZhdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRGVhY3RpdmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEZWFjdGl2YXRlKCkge1xuICAgICAgaWYgKHRoaXMub3JpZ2luYWxPcHRpb25zLm9uRGVhY3RpdmF0ZSkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsT3B0aW9ucy5vbkRlYWN0aXZhdGUuY2FsbChudWxsKTsgLy8gY2FsbCB1c2VyJ3MgaGFuZGxlciBvdXQgb2YgY29udGV4dFxuICAgICAgfVxuXG4gICAgICB0aGlzLmRlYWN0aXZhdGVUcmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVBvc3REZWFjdGl2YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVBvc3REZWFjdGl2YXRlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmaW5pc2hEZWFjdGl2YXRpb24gPSBmdW5jdGlvbiBmaW5pc2hEZWFjdGl2YXRpb24oKSB7XG4gICAgICAgIHZhciByZXR1cm5Gb2N1c05vZGUgPSBfdGhpczIuZ2V0UmV0dXJuRm9jdXNOb2RlKCk7XG5cbiAgICAgICAgdmFyIGNhblJldHVybkZvY3VzID0gISEoIC8vIGRpZCB0aGUgY29uc3VtZXIgYWxsb3cgaXQ/XG4gICAgICAgIF90aGlzMi5vcmlnaW5hbE9wdGlvbnMucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUgJiYgLy8gY2FuIHdlIGFjdHVhbGx5IGZvY3VzIHRoZSBub2RlP1xuICAgICAgICByZXR1cm5Gb2N1c05vZGUgIT09IG51bGwgJiYgcmV0dXJuRm9jdXNOb2RlICE9PSB2b2lkIDAgJiYgcmV0dXJuRm9jdXNOb2RlLmZvY3VzICYmICggLy8gd2FzIHRoZXJlIGFuIG91dHNpZGUgY2xpY2sgdGhhdCBhbGxvd2VkIGRlYWN0aXZhdGlvbj9cbiAgICAgICAgIV90aGlzMi5vdXRzaWRlQ2xpY2sgfHwgLy8gZGlkIHRoZSBjb25zdW1lciBhbGxvdyBkZWFjdGl2YXRpb24gd2hlbiB0aGUgb3V0c2lkZSBub2RlIHdhcyBjbGlja2VkP1xuICAgICAgICBfdGhpczIub3V0c2lkZUNsaWNrLmFsbG93RGVhY3RpdmF0aW9uICYmIC8vIGlzIHRoZSBvdXRzaWRlIG5vZGUgTk9UIGZvY3VzYWJsZSAoaW1wbHlpbmcgdGhhdCBpdCBkaWQgTk9UIHJlY2VpdmUgZm9jdXNcbiAgICAgICAgLy8gIGFzIGEgcmVzdWx0IG9mIHRoZSBjbGljay10aHJvdWdoKSAtLSBpbiB3aGljaCBjYXNlIGRvIE5PVCByZXN0b3JlIGZvY3VzXG4gICAgICAgIC8vICB0byBgcmV0dXJuRm9jdXNOb2RlYCBiZWNhdXNlIGZvY3VzIHNob3VsZCByZW1haW4gb24gdGhlIG91dHNpZGUgbm9kZVxuICAgICAgICAhaXNGb2N1c2FibGUoX3RoaXMyLm91dHNpZGVDbGljay50YXJnZXQsIF90aGlzMi5pbnRlcm5hbE9wdGlvbnMudGFiYmFibGVPcHRpb25zKSkgLy8gaWYgbm8sIHRoZSByZXN0b3JlIGZvY3VzIHRvIGByZXR1cm5Gb2N1c05vZGVgIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIF90aGlzMiRpbnRlcm5hbE9wdGlvbiA9IF90aGlzMi5pbnRlcm5hbE9wdGlvbnMucHJldmVudFNjcm9sbCxcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGwgPSBfdGhpczIkaW50ZXJuYWxPcHRpb24gPT09IHZvaWQgMCA/IGZhbHNlIDogX3RoaXMyJGludGVybmFsT3B0aW9uO1xuXG4gICAgICAgIGlmIChjYW5SZXR1cm5Gb2N1cykge1xuICAgICAgICAgIC8vIHJldHVybiBmb2N1cyB0byB0aGUgZWxlbWVudCB0aGF0IGhhZCBmb2N1cyB3aGVuIHRoZSB0cmFwIHdhcyBhY3RpdmF0ZWRcbiAgICAgICAgICByZXR1cm5Gb2N1c05vZGUuZm9jdXMoe1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbDogcHJldmVudFNjcm9sbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzMi5vcmlnaW5hbE9wdGlvbnMub25Qb3N0RGVhY3RpdmF0ZSkge1xuICAgICAgICAgIF90aGlzMi5vcmlnaW5hbE9wdGlvbnMub25Qb3N0RGVhY3RpdmF0ZS5jYWxsKG51bGwpOyAvLyBkb24ndCBjYWxsIGl0IGluIGNvbnRleHQgb2YgXCJ0aGlzXCJcblxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLm91dHNpZGVDbGljayA9IG51bGw7IC8vIHJlc2V0OiBubyBsb25nZXIgbmVlZGVkXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcmlnaW5hbE9wdGlvbnMuY2hlY2tDYW5SZXR1cm5Gb2N1cykge1xuICAgICAgICB0aGlzLm9yaWdpbmFsT3B0aW9ucy5jaGVja0NhblJldHVybkZvY3VzLmNhbGwobnVsbCwgdGhpcy5nZXRSZXR1cm5Gb2N1c05vZGUoKSkgLy8gY2FsbCBvdXQgb2YgY29udGV4dFxuICAgICAgICAudGhlbihmaW5pc2hEZWFjdGl2YXRpb24sIGZpbmlzaERlYWN0aXZhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5pc2hEZWFjdGl2YXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBGb2N1c1RyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBGb2N1c1RyYXAoKSB7XG4gICAgICBpZiAoIXRoaXMuZm9jdXNUcmFwKSB7XG4gICAgICAgIHZhciBmb2N1c1RyYXBFbGVtZW50RE9NTm9kZXMgPSB0aGlzLmZvY3VzVHJhcEVsZW1lbnRzLm1hcCggLy8gTk9URTogYGZpbmRET01Ob2RlKClgIGRvZXMgbm90IHN1cHBvcnQgQ1NTIHNlbGVjdG9yczsgaXQnbGwganVzdCByZXR1cm5cbiAgICAgICAgLy8gIGEgbmV3IHRleHQgbm9kZSB3aXRoIHRoZSB0ZXh0IHdyYXBwZWQgaW4gaXQgaW5zdGVhZCBvZiB0cmVhdGluZyB0aGVcbiAgICAgICAgLy8gIHN0cmluZyBhcyBhIHNlbGVjdG9yIGFuZCByZXNvbHZpbmcgaXQgdG8gYSBub2RlIGluIHRoZSBET01cbiAgICAgICAgUmVhY3RET00uZmluZERPTU5vZGUpO1xuICAgICAgICB2YXIgbm9kZXNFeGlzdCA9IGZvY3VzVHJhcEVsZW1lbnRET01Ob2Rlcy5zb21lKEJvb2xlYW4pO1xuXG4gICAgICAgIGlmIChub2Rlc0V4aXN0KSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3Byb3AtdHlwZXMgLS0gX2NyZWF0ZUZvY3VzVHJhcCBpcyBhbiBpbnRlcm5hbCBwcm9wXG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAgPSB0aGlzLnByb3BzLl9jcmVhdGVGb2N1c1RyYXAoZm9jdXNUcmFwRWxlbWVudERPTU5vZGVzLCB0aGlzLmludGVybmFsT3B0aW9ucyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5wcm9wcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmFjdGl2YXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5wYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmFjdGl2ZSkge1xuICAgICAgICB0aGlzLnNldHVwRm9jdXNUcmFwKCk7XG4gICAgICB9IC8vIGVsc2UsIHdhaXQgZm9yIGxhdGVyIGFjdGl2YXRpb24gaW4gY2FzZSB0aGUgYGZvY3VzVHJhcE9wdGlvbnNgIHdpbGwgYmUgdXBkYXRlZFxuICAgICAgLy8gIGFnYWluIGJlZm9yZSB0aGUgdHJhcCBpcyBhY3RpdmF0ZWQgKGUuZy4gaWYgd2FpdGluZyB0byBrbm93IHdoYXQgdGhlIGRvY3VtZW50XG4gICAgICAvLyAgb2JqZWN0IHdpbGwgYmUsIHNvIHRoZSBUcmFwIG11c3QgYmUgcmVuZGVyZWQsIGJ1dCB0aGUgY29uc3VtZXIgaXMgd2FpdGluZyB0b1xuICAgICAgLy8gIGFjdGl2YXRlIHVudGlsIHRoZXkgaGF2ZSBvYnRhaW5lZCB0aGUgZG9jdW1lbnQgZnJvbSBhIHJlZilcbiAgICAgIC8vICBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL2ZvY3VzLXRyYXAtcmVhY3QvaXNzdWVzLzUzOVxuXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAodGhpcy5mb2N1c1RyYXApIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5jb250YWluZXJFbGVtZW50cyAhPT0gdGhpcy5wcm9wcy5jb250YWluZXJFbGVtZW50cykge1xuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLnVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzKHRoaXMucHJvcHMuY29udGFpbmVyRWxlbWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhc0FjdGl2YXRlZCA9ICFwcmV2UHJvcHMuYWN0aXZlICYmIHRoaXMucHJvcHMuYWN0aXZlO1xuICAgICAgICB2YXIgaGFzRGVhY3RpdmF0ZWQgPSBwcmV2UHJvcHMuYWN0aXZlICYmICF0aGlzLnByb3BzLmFjdGl2ZTtcbiAgICAgICAgdmFyIGhhc1BhdXNlZCA9ICFwcmV2UHJvcHMucGF1c2VkICYmIHRoaXMucHJvcHMucGF1c2VkO1xuICAgICAgICB2YXIgaGFzVW5wYXVzZWQgPSBwcmV2UHJvcHMucGF1c2VkICYmICF0aGlzLnByb3BzLnBhdXNlZDtcblxuICAgICAgICBpZiAoaGFzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQcmV2aW91c0VsZW1lbnQoKTtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgICAgdGhpcy5kZWFjdGl2YXRlVHJhcCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gdW4vcGF1c2UgZG9lcyBub3RoaW5nIG9uIGFuIGluYWN0aXZlIHRyYXBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNQYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5wYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1VucGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAudW5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOT1RFOiBpZiB3ZSdyZSBpbiBgY29tcG9uZW50RGlkVXBkYXRlYCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIHRyYXAgeWV0LFxuICAgICAgICAvLyAgaXQgZWl0aGVyIG1lYW5zIGl0IHNob3VsZG4ndCBiZSBhY3RpdmUsIG9yIGl0IHNob3VsZCBiZSBidXQgbm9uZSBvZlxuICAgICAgICAvLyAgb2YgZ2l2ZW4gYGNvbnRhaW5lckVsZW1lbnRzYCB3ZXJlIHByZXNlbnQgaW4gdGhlIERPTSB0aGUgbGFzdCB0aW1lXG4gICAgICAgIC8vICB3ZSB0cmllZCB0byBjcmVhdGUgdGhlIHRyYXBcbiAgICAgICAgaWYgKHByZXZQcm9wcy5jb250YWluZXJFbGVtZW50cyAhPT0gdGhpcy5wcm9wcy5jb250YWluZXJFbGVtZW50cykge1xuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwRWxlbWVudHMgPSB0aGlzLnByb3BzLmNvbnRhaW5lckVsZW1lbnRzO1xuICAgICAgICB9IC8vIGRvbid0IGNyZWF0ZSB0aGUgdHJhcCB1bmxlc3MgaXQgc2hvdWxkIGJlIGFjdGl2ZSBpbiBjYXNlIHRoZSBjb25zdW1lclxuICAgICAgICAvLyAgaXMgc3RpbGwgdXBkYXRpbmcgYGZvY3VzVHJhcE9wdGlvbnNgXG4gICAgICAgIC8vICBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL2ZvY3VzLXRyYXAtcmVhY3QvaXNzdWVzLzUzOVxuXG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQcmV2aW91c0VsZW1lbnQoKTtcbiAgICAgICAgICB0aGlzLnNldHVwRm9jdXNUcmFwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLmRlYWN0aXZhdGVUcmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5wcm9wcy5jaGlsZHJlbiA/IFJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbikgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSAmJiBjaGlsZC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBmb2N1cy10cmFwIGNhbm5vdCB1c2UgYSBGcmFnbWVudCBhcyBpdHMgY2hpbGQgY29udGFpbmVyLiBUcnkgcmVwbGFjaW5nIGl0IHdpdGggYSA8ZGl2PiBlbGVtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXBvc2VkUmVmQ2FsbGJhY2sgPSBmdW5jdGlvbiBjb21wb3NlZFJlZkNhbGxiYWNrKGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyRWxlbWVudHMgPSBfdGhpczMucHJvcHMuY29udGFpbmVyRWxlbWVudHM7XG5cbiAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnJlZihlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQucmVmKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczMuZm9jdXNUcmFwRWxlbWVudHMgPSBjb250YWluZXJFbGVtZW50cyA/IGNvbnRhaW5lckVsZW1lbnRzIDogW2VsZW1lbnRdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjaGlsZFdpdGhSZWYgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICByZWY6IGNvbXBvc2VkUmVmQ2FsbGJhY2tcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGlsZFdpdGhSZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb2N1c1RyYXA7XG59KFJlYWN0LkNvbXBvbmVudCk7IC8vIHN1cHBvcnQgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdoZXJlIGBFbGVtZW50YCB3aWxsIG5vdCBiZSBkZWZpbmVkXG5cblxudmFyIEVsZW1lbnRUeXBlID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gRnVuY3Rpb24gOiBFbGVtZW50O1xuRm9jdXNUcmFwLnByb3BUeXBlcyA9IHtcbiAgYWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgcGF1c2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgZm9jdXNUcmFwT3B0aW9uczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBkb2N1bWVudDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvbkFjdGl2YXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBvc3RBY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hlY2tDYW5Gb2N1c1RyYXA6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVhY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Qb3N0RGVhY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgY2hlY2tDYW5SZXR1cm5Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaW5pdGlhbEZvY3VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSksIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGZhbGxiYWNrRm9jdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5pbnN0YW5jZU9mKEVsZW1lbnRUeXBlKSwgUHJvcFR5cGVzLnN0cmluZywgLy8gTk9URTogZG9lcyBub3Qgc3VwcG9ydCBgZmFsc2VgIGFzIHZhbHVlIChvciByZXR1cm4gdmFsdWUgZnJvbSBmdW5jdGlvbilcbiAgICBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGVzY2FwZURlYWN0aXZhdGVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IFByb3BUeXBlcy5ib29sLFxuICAgIHNldFJldHVybkZvY3VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSksIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGFsbG93T3V0c2lkZUNsaWNrOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBwcmV2ZW50U2Nyb2xsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB0YWJiYWJsZU9wdGlvbnM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBkaXNwbGF5Q2hlY2s6IFByb3BUeXBlcy5vbmVPZihbJ2Z1bGwnLCAnbm9uLXplcm8tYXJlYScsICdub25lJ10pLFxuICAgICAgZ2V0U2hhZG93Um9vdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSlcbiAgICB9KVxuICB9KSxcbiAgY29udGFpbmVyRWxlbWVudHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5pbnN0YW5jZU9mKEVsZW1lbnRUeXBlKSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCwgLy8gUmVhY3QgZWxlbWVudFxuICBQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSkgLy8gRE9NIGVsZW1lbnRcbiAgXSkgLy8gTk9URTogX2NyZWF0ZUZvY3VzVHJhcCBpcyBpbnRlcm5hbCwgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSwgc28gd2UgZG9uJ3RcbiAgLy8gIHNwZWNpZnkgaXQgaGVyZS4gSXQncyBleHBlY3RlZCB0byBiZSBzZXQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGZyb21cbiAgLy8gIHJlcXVpcmUoJ2ZvY3VzLXRyYXAnKSwgb3Igb25lIHdpdGggYSBjb21wYXRpYmxlIGludGVyZmFjZS5cblxufTtcbkZvY3VzVHJhcC5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGl2ZTogdHJ1ZSxcbiAgcGF1c2VkOiBmYWxzZSxcbiAgZm9jdXNUcmFwT3B0aW9uczoge30sXG4gIF9jcmVhdGVGb2N1c1RyYXA6IGNyZWF0ZUZvY3VzVHJhcFxufTtcbm1vZHVsZS5leHBvcnRzID0gRm9jdXNUcmFwOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js\n");

/***/ })

};
;